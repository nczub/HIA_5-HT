Node name is node3
Start Tue Nov 15 01:26:17 PM CET 2022
Processing A_AutoML_mljar_v9_regression_full_HIA_config_9_USERCONFIG_9.tar.gz
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
My algorithms ['Baseline', 'Linear', 'Decision Tree', 'Random Forest', 'Extra Trees', 'LightGBM', 'Xgboost', 'CatBoost', 'Neural Network', 'Nearest Neighbors']
Random seed: 763565
Linear algorithm was disabled.
AutoML directory: mljar_AutoML_Compete_2022_11_15_13_28_31
The task is regression with evaluation metric rmse
AutoML will use algorithms: ['Baseline', 'Decision Tree', 'Random Forest', 'Extra Trees', 'LightGBM', 'Xgboost', 'CatBoost', 'Neural Network', 'Nearest Neighbors']
AutoML will ensemble availabe models
AutoML steps: ['simple_algorithms', 'default_algorithms', 'not_so_random', 'golden_features', 'insert_random_feature', 'features_selection', 'hill_climbing_1', 'hill_climbing_2', 'ensemble']
* Step simple_algorithms will try to check up to 4 models
Custom validation strategy
Split 0.
Train 88 samples.
Validation 10 samples.
Split 1.
Train 88 samples.
Validation 10 samples.
Split 2.
Train 88 samples.
Validation 10 samples.
Split 3.
Train 88 samples.
Validation 10 samples.
Split 4.
Train 88 samples.
Validation 10 samples.
Split 5.
Train 88 samples.
Validation 10 samples.
Split 6.
Train 88 samples.
Validation 10 samples.
Split 7.
Train 88 samples.
Validation 10 samples.
Split 8.
Train 89 samples.
Validation 9 samples.
Split 9.
Train 89 samples.
Validation 9 samples.
1_Baseline rmse 22.694876 trained in 5.48 seconds
2_DecisionTree rmse 30.368702 trained in 5.96 seconds
3_DecisionTree rmse 28.206009 trained in 5.89 seconds
4_DecisionTree rmse 31.270101 trained in 6.03 seconds
* Step default_algorithms will try to check up to 6 models
5_Default_LightGBM rmse 21.500398 trained in 9.35 seconds
6_Default_Xgboost rmse 23.307335 trained in 17.27 seconds
7_Default_CatBoost rmse 21.904602 trained in 38.11 seconds
8_Default_NeuralNetwork rmse 32.6249 trained in 20.53 seconds
9_Default_RandomForest rmse 22.382022 trained in 26.39 seconds
10_Default_ExtraTrees rmse 21.672622 trained in 23.28 seconds
* Step not_so_random will try to check up to 54 models
20_LightGBM rmse 22.211938 trained in 8.1 seconds
11_Xgboost rmse 21.901749 trained in 10.41 seconds
29_CatBoost rmse 21.763511 trained in 28.0 seconds
38_RandomForest rmse 19.705742 trained in 23.68 seconds
47_ExtraTrees rmse 22.671048 trained in 21.87 seconds
56_NeuralNetwork rmse 45.976622 trained in 19.48 seconds
21_LightGBM rmse 22.717986 trained in 8.55 seconds
12_Xgboost rmse 21.891493 trained in 8.67 seconds
30_CatBoost rmse 23.397775 trained in 114.17 seconds
39_RandomForest rmse 20.250088 trained in 23.09 seconds
48_ExtraTrees rmse 23.341984 trained in 21.9 seconds
57_NeuralNetwork rmse 27.259847 trained in 21.37 seconds
22_LightGBM rmse 22.108877 trained in 9.14 seconds
13_Xgboost rmse 22.499422 trained in 16.19 seconds
31_CatBoost rmse 22.07722 trained in 30.01 seconds
40_RandomForest rmse 22.142517 trained in 26.83 seconds
49_ExtraTrees rmse 22.392253 trained in 28.16 seconds
58_NeuralNetwork rmse 31.158184 trained in 24.01 seconds
23_LightGBM rmse 22.385607 trained in 9.36 seconds
14_Xgboost rmse 21.942026 trained in 9.3 seconds
32_CatBoost rmse 21.799912 trained in 32.61 seconds
41_RandomForest rmse 22.741815 trained in 36.22 seconds
50_ExtraTrees rmse 22.449643 trained in 22.35 seconds
59_NeuralNetwork rmse 24.399222 trained in 22.5 seconds
24_LightGBM rmse 22.694876 trained in 8.66 seconds
15_Xgboost rmse 21.659649 trained in 14.92 seconds
33_CatBoost rmse 23.561859 trained in 112.5 seconds
42_RandomForest rmse 21.457844 trained in 26.7 seconds
51_ExtraTrees rmse 22.853052 trained in 30.5 seconds
60_NeuralNetwork rmse 29.070588 trained in 22.48 seconds
25_LightGBM rmse 21.9842 trained in 10.94 seconds
16_Xgboost rmse 22.432974 trained in 13.66 seconds
34_CatBoost rmse 22.360982 trained in 33.03 seconds
43_RandomForest rmse 20.575679 trained in 30.12 seconds
52_ExtraTrees rmse 22.901244 trained in 25.4 seconds
61_NeuralNetwork rmse 31.685404 trained in 25.48 seconds
26_LightGBM rmse 21.754985 trained in 11.46 seconds
17_Xgboost rmse 21.955795 trained in 10.86 seconds
35_CatBoost rmse 21.877658 trained in 30.58 seconds
44_RandomForest rmse 22.465577 trained in 31.55 seconds
53_ExtraTrees rmse 22.440981 trained in 25.02 seconds
62_NeuralNetwork rmse 27.027518 trained in 22.61 seconds
27_LightGBM rmse 22.694876 trained in 10.01 seconds
18_Xgboost rmse 22.506833 trained in 21.64 seconds
36_CatBoost rmse 22.781647 trained in 56.44 seconds
45_RandomForest rmse 20.905274 trained in 25.74 seconds
54_ExtraTrees rmse 22.9946 trained in 28.94 seconds
63_NeuralNetwork rmse 37.233448 trained in 22.04 seconds
28_LightGBM rmse 21.139589 trained in 15.34 seconds
19_Xgboost rmse 22.014858 trained in 24.55 seconds
37_CatBoost rmse 22.668094 trained in 53.41 seconds
46_RandomForest rmse 21.456018 trained in 24.75 seconds
55_ExtraTrees rmse 22.676095 trained in 24.61 seconds
64_NeuralNetwork rmse 26.014478 trained in 23.81 seconds
* Step golden_features will try to check up to 3 models
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
None 100
Add Golden Feature: GATS4Z_ratio_ETA_shape_y
Add Golden Feature: ATSC0are_ratio_nG12FRing
Add Golden Feature: ATSC0are_ratio_nG12FARing
Add Golden Feature: piPC10_sum_GATS8i
Add Golden Feature: GGI7_ratio_nG12FARing
Add Golden Feature: ATSC1are_diff_piPC3
Add Golden Feature: MATS8v_diff_piPC8
Add Golden Feature: piPC10_sum_GATS7d
Add Golden Feature: ATSC0pe_ratio_nG12FRing
Add Golden Feature: ATSC0pe_ratio_nG12FARing
Add Golden Feature: AATSC6s_diff_piPC8
Add Golden Feature: ATSC1pe_diff_piPC2
Add Golden Feature: piPC7_sum_GATS8p
Add Golden Feature: EState_VSA10_sum_SpMAD_Dzv
Add Golden Feature: NdssC_ratio_Xp-6d
Add Golden Feature: piPC9_sum_GATS7d
Add Golden Feature: Xp-6d_ratio_nFRing
Add Golden Feature: GGI5_multiply_VSA_EState3
Add Golden Feature: EState_VSA10_multiply_ATS7dv
Add Golden Feature: EState_VSA10_multiply_LogEE_Dzv
Add Golden Feature: EState_VSA10_sum_AATSC4s
Add Golden Feature: TopoPSA(NO)_sum_ATSC4p
Add Golden Feature: AATSC5i_diff_piPC9
Add Golden Feature: piPC10_sum_MATS5pe
Add Golden Feature: TopoPSA(NO)_ratio_GATS7d
Add Golden Feature: EState_VSA10_sum_MATS7d
Add Golden Feature: SM1_Dzpe_sum_MATS3p
Add Golden Feature: piPC8_sum_GATS8v
Add Golden Feature: MATS1are_diff_piPC10
Add Golden Feature: EState_VSA10_sum_AATS8s
Add Golden Feature: WPath_ratio_nG12FARing
Add Golden Feature: piPC8_sum_GATS7d
Add Golden Feature: ATSC6i_diff_TopoPSA
Add Golden Feature: piPC7_multiply_EState_VSA10
Add Golden Feature: VSA_EState2_ratio_nG12FARing
Add Golden Feature: ATSC7c_ratio_nG12FARing
Add Golden Feature: EState_VSA10_sum_ETA_eta_BR
Add Golden Feature: TopoPSA_multiply_nG12FARing
Add Golden Feature: TopoPSA(NO)_multiply_nG12FRing
Add Golden Feature: JGI7_multiply_ATSC0c
Add Golden Feature: piPC10_sum_GATS8v
Add Golden Feature: MATS8v_diff_piPC10
Add Golden Feature: MATS8m_diff_TpiPC10
Add Golden Feature: AATSC0s_multiply_ATS6se
Add Golden Feature: Sse_ratio_nFRing
Add Golden Feature: JGI10_multiply_SdO
Add Golden Feature: AATS1are_diff_piPC10
Add Golden Feature: piPC10_ratio_AATS1are
Add Golden Feature: TIC2_multiply_AATS0s
Add Golden Feature: AATS1are_ratio_piPC10
Add Golden Feature: piPC8_sum_BCUTs-1l
Add Golden Feature: SlogP_VSA2_sum_AATS7Z
Add Golden Feature: piPC7_sum_GATS7d
Add Golden Feature: EState_VSA10_sum_MATS4c
Add Golden Feature: SpAbs_Dzpe_ratio_nFRing
Add Golden Feature: piPC9_multiply_AXp-0d
Add Golden Feature: MATS7d_diff_piPC10
Add Golden Feature: TpiPC10_sum_GATS7d
Add Golden Feature: MATS2s_diff_piPC10
Add Golden Feature: SM1_Dzpe_ratio_nG12FRing
Add Golden Feature: ETA_shape_y_ratio_GATS4Z
Add Golden Feature: ETA_eta_R_ratio_nG12FARing
Add Golden Feature: AATS4Z_diff_TopoPSA
Add Golden Feature: piPC8_multiply_EState_VSA2
Add Golden Feature: piPC9_sum_MATS5pe
Add Golden Feature: AXp-4d_ratio_ATS0s
Add Golden Feature: ATS0s_diff_ATSC2d
Add Golden Feature: ATSC6c_diff_piPC9
Add Golden Feature: EState_VSA10_diff_n5ARing
Add Golden Feature: EState_VSA10_multiply_ATS0are
Add Golden Feature: EState_VSA10_multiply_SpMAD_Dzm
Add Golden Feature: EState_VSA10_multiply_ATS0se
Add Golden Feature: EState_VSA10_multiply_Sse
Add Golden Feature: AATS0s_multiply_ATS3pe
Add Golden Feature: GATS3d_diff_TpiPC10
Add Golden Feature: SMR_VSA2_diff_EState_VSA10
Add Golden Feature: TpiPC10_sum_AATSC5s
Add Golden Feature: nG12FARing_ratio_ETA_eta_R
Add Golden Feature: n10FAHRing_sum_piPC8
Add Golden Feature: TopoPSA(NO)_sum_AATSC8m
Add Golden Feature: MATS8m_diff_piPC10
Add Golden Feature: MATS8Z_diff_piPC10
Add Golden Feature: TopoPSA(NO)_ratio_nG12FRing
Add Golden Feature: VR1_Dzi_ratio_nG12FARing
Add Golden Feature: Xp-4d_diff_MID_X
Add Golden Feature: RPCG_diff_EState_VSA10
Add Golden Feature: SsOH_multiply_ATS8dv
Add Golden Feature: ATS6Z_ratio_nG12FRing
Add Golden Feature: EState_VSA10_ratio_GATS5v
Add Golden Feature: EState_VSA10_sum_ETA_epsilon_1
Add Golden Feature: SdO_multiply_ATSC1d
Add Golden Feature: nG12FARing_ratio_VSA_EState5
Add Golden Feature: SpMax_Dzse_ratio_nFRing
Add Golden Feature: LogEE_Dzse_ratio_nFRing
Add Golden Feature: TopoPSA_multiply_ATSC0dv
Add Golden Feature: EState_VSA10_sum_NssNH
Add Golden Feature: Kier2_diff_SMR_VSA1
Add Golden Feature: ATSC7dv_ratio_nG12FRing
Add Golden Feature: piPC8_sum_GATS7dv
Add Golden Feature: SM1_Dzpe_sum_MATS3i
Created 100 Golden Features in 119.75 seconds.
38_RandomForest_GoldenFeatures rmse 18.050624 trained in 149.77 seconds
39_RandomForest_GoldenFeatures rmse 20.056737 trained in 30.7 seconds
43_RandomForest_GoldenFeatures rmse 21.087002 trained in 29.96 seconds
* Step insert_random_feature will try to check up to 1 model
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
38_RandomForest_GoldenFeatures_RandomFeature rmse 20.862029 trained in 261.29 seconds
Drop features ['AATSC5s', 'Sse_ratio_nFRing', 'JGI10_multiply_SdO', 'GGI8', 'ATSC8p', 'ATSC7dv_ratio_nG12FRing', 'Xch-5dv', 'RPCG', 'MATS8Z_diff_piPC10', 'TopoPSA(NO)_ratio_GATS7d', 'TpiPC10_sum_AATSC5s', 'ATSC6d', 'ATSC7c_ratio_nG12FARing', 'ATSC5s', 'TpiPC10', 'ATSC8d', 'SdO_multiply_ATSC1d', 'MATS2c', 'MATS4m', 'ATS4m', 'piPC10_sum_GATS8i', 'AATS2i', 'Xc-5dv', 'GGI6', 'LogEE_Dzi', 'ATSC6c_diff_piPC9', 'MATS1d', 'GGI9', 'MATS7m', 'AATSC1m', 'ATS7Z', 'TSRW10', 'ATSC1d', 'EState_VSA10_multiply_SpMAD_Dzm', 'MIC4', 'AATS1p', 'ATSC0s', 'MATS2dv', 'ETA_eta_F', 'ATSC7dv', 'AXp-1dv', 'piPC10_ratio_AATS1are', 'AATSC6se', 'GGI7', 'ATSC2s', 'MATS3se', 'MATS5dv', 'ATSC7are', 'MIC2', 'MIC3', 'ATS7i', 'AATS3i', 'JGI8', 'MATS1dv', 'ETA_epsilon_2', 'SLogP', 'AATS7are', 'ATS0s', 'AATSC8m', 'AATSC7i', 'EState_VSA2', 'EState_VSA10_sum_NssNH', 'AATSC3dv', 'ATS7m', 'GATS6pe', 'nG12FARing_ratio_VSA_EState5', 'ATSC7Z', 'GATS1pe', 'GATS1c', 'GATS7are', 'piPC9_sum_MATS5pe', 'SssCH2', 'AATS6i', 'AATS0v', 'BCUTv-1h', 'AATS3d', 'GATS1se', 'ATSC7pe', 'EState_VSA10_ratio_GATS5v', 'GATS4dv', 'GATS2p', 'GATS5s', 'GATS7m', 'ATSC8m', 'MATS7d', 'ATSC7v', 'RPCG_diff_EState_VSA10', 'ETA_shape_p', 'piPC9_multiply_AXp-0d', 'GATS6se', 'Xch-6d', 'ATSC6m', 'ATS8Z', 'AATSC0p', 'CIC0', 'EState_VSA5', 'AATSC2Z', 'AATS8i', 'GATS3pe', 'MATS5i', 'AATSC3p', 'SpMAD_A', 'nG12FARing_ratio_ETA_eta_R', 'GATS6p', 'ATS0s_diff_ATSC2d', 'GATS8dv', 'SM1_Dzv', 'JGI2', 'ETA_eta_B', 'CIC1', 'GATS8Z', 'AETA_eta_BR', 'GATS4are', 'BIC0', 'MATS3s', 'AATS1are_ratio_piPC10', 'MATS6are', 'AATSC5i_diff_piPC9', 'AATSC6m', 'GATS5dv', 'ATS0m', 'BCUTi-1h', 'AXp-5dv', 'ATSC4d', 'AXp-3dv', 'ATS2pe', 'AATSC8s', 'ATS3dv', 'BCUTc-1h', 'SpAbs_A', 'AATS0m', 'StsC', 'SpMax_Dzpe', 'AETA_eta', 'nHBDon', 'AETA_eta_F', 'VR2_Dzse', 'SpDiam_DzZ', 'GATS7v', 'MATS2d', 'MATS7pe', 'SM1_Dzm', 'MATS3i', 'NaaO', 'VE3_Dzm', 'SdssC', 'ATSC0v', 'TopoPSA_multiply_ATSC0dv', 'SaaaC', 'n6HRing', 'C4SP3', 'JGI3', 'CIC2', 'GATS3p', 'nFARing', 'Diameter', 'GATS8c', 'MWC08', 'ATS2s', 'Xpc-6dv', 'BIC5', 'GATS6i', 'ATS4i', 'ETA_beta', 'GATS4se', 'VR1_Dzm', 'nARing', 'TIC2', 'SpAD_DzZ', 'TopoPSA_multiply_nG12FARing', 'MATS8v', 'AATSC0se', 'NsssN', 'AATS0dv', 'ATS0i', 'MATS4are', 'VE3_Dzse', 'SpDiam_Dzare', 'SMR_VSA4', 'nBondsA', 'ATS8s', 'AATS8dv', 'Xpc-4dv', 'SssNH', 'TpiPC10_sum_GATS7d', 'SM1_Dzpe_ratio_nG12FRing', 'AXp-2dv', 'AATS1v', 'ABC', 'n4Ring', 'JGI10', 'ATS4are', 'GGI3', 'ATS8m', 'AATS5m', 'SpMax_Dzv', 'SdsN', 'HybRatio', 'GATS5se', 'AETA_beta', 'AATSC6c', 'nBondsT', 'MATS5c', 'AATS2Z', 'nG12FRing', 'ETA_eta_FL', 'Sare', 'ATS2i', 'nH', 'AATS4Z', 'AATS2dv', 'Xc-4d', 'SIC2', 'AATSC8i', 'Xch-7dv', 'ATSC0are_ratio_nG12FARing', 'VE2_Dzpe', 'MATS4dv', 'ZMIC0', 'mZagreb1', 'AATSC7dv', 'MATS5se', 'MATS1Z', 'ATSC2are', 'ETA_dPsi_A', 'LogEE_Dzpe', 'ATS2Z', 'MATS6d', 'SpDiam_Dzpe', 'ATSC3m', 'Xp-4d', 'ATS4dv', 'SpAbs_Dzm', 'SM1_Dzpe', 'bpol', 'n6Ring', 'MATS4i', 'SMR_VSA2_diff_EState_VSA10', 'SpAD_Dzse', 'AATSC0i', 'AATS5dv', 'SMR_VSA7', 'AATSC3c', 'TopoShapeIndex', 'Vabc', 'GATS4c', 'VR1_Dzi', 'C2SP1', 'MWC09', 'ECIndex', 'n12FHRing', 'AATSC2m', 'NsBr', 'SpDiam_Dzm', 'MATS4pe', 'ATS3v', 'ETA_shape_y', 'BCUTp-1l', 'NdO', 'ATSC8se', 'GATS4p', 'AATS4s', 'ATSC6dv', 'Lipinski', 'AATSC3v', 'SpAD_Dzpe', 'AETA_eta_RL', 'MATS7c', 'NsNH2', 'AATS5i', 'EState_VSA10_sum_ETA_epsilon_1', 'ATS2are', 'NtN', 'ATS5Z', 'NsOH', 'SIC4', 'BCUTp-1h', 'ATSC1are_diff_piPC3', 'EState_VSA10_sum_SpMAD_Dzv', 'GGI7_ratio_nG12FARing', 'LogEE_Dzp', 'ATS3d', 'SpMAD_DzZ', 'ATSC3v', 'ATSC7m', 'NaaaC', 'SlogP_VSA5', 'ATS6i', 'VR2_Dzm', 'ATSC5m', 'SlogP_VSA8', 'AATS7p', 'piPC7_sum_GATS7d', 'AMW', 'ETA_epsilon_4', 'AATSC8p', 'AETA_dBeta', 'AATSC5m', 'AXp-6d', 'ATSC2pe', 'MDEC-22', 'n9FHRing', 'AATSC0m', 'AATSC2p', 'AATS7d', 'AATS1m', 'MID_h', 'LogEE_Dzse', 'VR2_Dzi', 'ATSC5c', 'n6aHRing', 'NtsC', 'WPath', 'PEOE_VSA1', 'AATSC5dv', 'MWC06', 'nBondsS', 'GATS4pe', 'ETA_epsilon_3', 'SddssS', 'AATSC6dv', 'ATSC4v', 'MATS3v', 'AATSC8dv', 'MATS4d', 'ATS2p', 'ATSC0se', 'AATS4d', 'SpAbs_Dzp', 'AATS5d', 'MATS7are', 'StCH', 'ATS6pe', 'MATS4Z', 'SpMax_Dzare', 'Xp-5dv', 'AATSC4s', 'GATS4m', 'Xp-1d', 'MATS4v', 'AATSC6s', 'AATSC5v', 'GATS7p', 'AATSC4m', 'MATS2are', 'AATS7m', 'JGI4', 'MATS7Z', 'SIC5', 'VE2_DzZ', 'EState_VSA7', 'AETA_beta_ns_d', 'Mse', 'AATS7i', 'VSA_EState2', 'ATS1d', 'SaaN', 'MATS8se', 'ATS4d', 'piPC8', 'ATS5d', 'JGI1', 'nRing', 'ATS3s', 'BIC3', 'MPC6', 'VE1_Dzm', 'SpAD_Dzi', 'SpMAD_Dzm', 'naHRing', 'n7ARing', 'n4ARing', 'ATSC1s', 'MATS3d', 'VR1_Dzse', 'ATS1m', 'AATS1are_diff_piPC10', 'GATS8v', 'AATS5Z', 'AATSC6d', 'MW', 'ATS0dv', 'VE3_Dzpe', 'NsCH3', 'EState_VSA9', 'GATS6are', 'ETA_shape_y_ratio_GATS4Z', 'AATSC5Z', 'n10FaRing', 'MPC9', 'AATSC1are', 'EState_VSA10_diff_n5ARing', 'AATSC7are', 'ATSC4s', 'VSA_EState8', 'nAromAtom', 'ATSC3s', 'VE3_DzZ', 'piPC8_multiply_EState_VSA2', 'ATSC5are', 'AATSC8are', 'VR1_A', 'EState_VSA1', 'MATS8m_diff_piPC10', 'ATSC3are', 'ETA_epsilon_5', 'ATS5m', 'GGI2', 'ATS6v', 'AATS8m', 'n9FaHRing', 'n10FaHRing', 'ATSC8are', 'n12FARing', 'AATS2m', 'SpAD_Dzm', 'AATS4m', 'ATSC5d', 'GATS7dv', 'AATSC7pe', 'ATS1v', 'ATS4se', 'MATS7d_diff_piPC10', 'GGI1', 'ATSC4Z', 'TopoPSA(NO)', 'VE1_DzZ', 'n10FAHRing', 'SpAbs_DzZ', 'n9FAHRing', 'n5ARing', 'AATSC3i', 'ATS4v', 'AATSC7p', 'MPC3', 'MPC4', 'ATSC2c', 'ABCGG', 'ATS6s', 'PEOE_VSA5', 'AATS7v', 'piPC4', 'VE1_Dzv', 'SlogP_VSA11', 'n12FRing', 'AATS3are', 'MATS4c', 'MATS8d', 'LogEE_Dzv', 'MATS8c', 'Kier1', 'ATS5s', 'ATS8se', 'AATSC4dv', 'IC0', 'ATS1s', 'ATSC4m', 'AATS4p', 'SlogP_VSA4', 'ATS1dv', 'ATS0se', 'nHBAcc', 'nN', 'nO', 'SMR_VSA2', 'ATS2dv', 'PEOE_VSA8', 'AATS0pe', 'MATS1c', 'ETA_dPsi_B', 'ATSC1c', 'WPath_ratio_nG12FARing', 'VE2_Dzv', 'piPC8_sum_GATS7d', 'AATSC6v', 'piPC9_sum_GATS7d', 'nBase', 'ATSC7se', 'ATSC6p', 'nFRing', 'ETA_dEpsilon_B', 'AATSC2d', 'AATS5pe', 'AATS2are', 'AATS8d', 'n5HRing', 'piPC10_sum_MATS5pe', 'nHRing', 'ATSC6pe', 'JGI6', 'ATSC5pe', 'AATS1s', 'AATSC0s_multiply_ATS6se', 'MATS8m_diff_TpiPC10', 'AATS1pe', 'AATS8se', 'AATS5s', 'AATS3se', 'AATS6s', 'AATS7s', 'nHetero', 'AATSC3Z', 'AATSC4v', 'piPC10', 'AATSC0pe', 'GATS5pe', 'SddsN', 'MATS5m', 'GATS8se', 'AATSC7se', 'ATS0are', 'GATS8s', 'BCUTse-1h', 'AATSC1pe', 'Xp-2d', 'MATS5Z', 'MATS7se', 'NdS', 'SM1_Dzare', 'MATS8m', 'ATS5pe', 'NaaS', 'ATS5i', 'MATS3Z', 'MATS2Z', 'BCUTm-1l', 'ATS1are', 'BertzCT', 'VR1_D', 'SZ', 'ETA_eta', 'AXp-3d', 'ATS3i', 'SpDiam_Dzse', 'Sse', 'SpAbs_Dzare', 'SssssC', 'GATS7d', 'Xch-4dv', 'MATS5s', 'Xch-5d', 'Xch-4d', 'MZ', 'Xc-3dv', 'SM1_Dzp', 'ATS8pe', 'MATS4p', 'AXp-7d', 'NaaCH', 'ETA_dAlpha_A', 'WPol', 'SRW10', 'SRW08', 'GATS1s', 'nBondsD', 'GATS2are', 'ATSC1p', 'SRW06', 'MATS5v', 'VR2_Dzpe', 'VR1_Dzpe', 'VE1_Dzpe', 'VE1_Dzse', 'AATSC6i', 'ETA_beta_ns', 'ETA_beta_s', 'MWC05', 'Sm', 'GATS5c', 'nBondsM', 'MATS6p', 'ATS1p', 'ETA_beta_ns_d', 'Xp-4dv', 'nBondsKS', 'GATS2d', 'SsCl', 'JGI9', 'JGT10', 'MATS2v', 'MATS5are', 'VR2_Dzare', 'MATS7s', 'AATSC0Z', 'ATSC0dv', 'AMID', 'MATS4s', 'NaaN', 'NsF', 'Zagreb2', 'MATS3c', 'ATSC7p', 'PEOE_VSA10', 'AMID_h', 'nBondsKD', 'ATSC0p', 'SpAD_Dzare', 'MATS2s_diff_piPC10', 'Zagreb1', 'SM1_Dzpe_sum_MATS3i', 'BCUTare-1h', 'ATS6Z', 'AATS6Z', 'nFaRing', 'VE3_Dzv', 'ATS8dv', 'ATS3p', 'ATS0pe', 'ATS5are', 'ATS7p', 'ATSC4dv', 'AATSC7c', 'BCUTZ-1h', 'ATSC3i', 'ATSC4i', 'SMR_VSA6', 'MATS5d', 'AATS0se', 'ATS8d', 'AATS3dv', 'nAromBond', 'PEOE_VSA13', 'ATS6m', 'SdsCH', 'ATSC6i', 'MATS7i', 'ATS0v', 'AATSC1d', 'MID_O', 'ATSC4p', 'BCUTse-1l', 'GATS2Z', 'n6ARing', 'RNCG', 'VSA_EState7', 'AATS3m', 'n8FARing', 'Xc-4dv', 'EState_VSA10_multiply_ATS0se', 'AATSC5pe', 'ATSC4se', 'SpAD_Dzv', 'Xpc-5d', 'AXp-6dv', 'SRW09', 'ATS1Z', 'PetitjeanIndex', 'nFHRing', 'ETA_shape_x', 'PEOE_VSA2', 'SlogP_VSA2_sum_AATS7Z', 'nAcid', 'ATS3pe', 'VE1_D', 'MATS1are_diff_piPC10', 'Xc-6dv', 'AATSC4p', 'Kier2', 'Kier3', 'Xp-0dv', 'MATS8i', 'AATS0i', 'Xp-1dv', 'C2SP3', 'CIC3', 'Xch-6dv', 'SpMAD_Dzp', 'VE3_Dzare', 'ATSC5Z', 'BCUTare-1l', 'SpAD_A', 'EState_VSA10_sum_AATS8s', 'MATS2se', 'NssO', 'AATSC8se', 'AATS7Z', 'Xpc-6d', 'SMR_VSA3', 'ATSC5se', 'AATSC8Z', 'AATS2s', 'nHeavyAtom', 'AATSC7Z', 'VR3_Dzse', 'ETA_eta_L', 'nG12FHRing', 'AATS3p', 'MATS6s', 'ATSC3Z', 'IC4', 'MATS1are', 'EState_VSA10_multiply_LogEE_Dzv', 'ZMIC2', 'AATS2p', 'ETA_dEpsilon_A', 'AATS1i', 'Xp-3d', 'Mm', 'SpMAD_Dzse', 'SpAbs_Dzi', 'AATS4Z_diff_TopoPSA', 'AXp-4d_ratio_ATS0s', 'GATS3v', 'ATSC3d', 'AATS7pe', 'AATSC0dv', 'MATS8Z', 'ATS3m', 'AATS1are', 'ATS7d', 'ATS4Z', 'MATS2m', 'MPC5', 'AATS4pe', 'SpMax_DzZ', 'AATS3pe', 'AATS2pe', 'MATS6i', 'BCUTpe-1h', 'ATSC5p', 'AATSC0c', 'MATS6m', 'AMID_N', 'ATSC8i', 'LogEE_Dzm', 'ATSC3se', 'AATSC0d', 'MATS5p', 'ATS2v', 'SpMax_Dzm', 'SsNH2', 'piPC10_sum_GATS7d', 'AATS5are', 'VSA_EState3', 'MDEC-23', 'AETA_eta_L', 'GATS2i', 'SpMax_Dzp', 'ETA_dEpsilon_C', 'SpDiam_Dzi', 'BCUTZ-1l', 'AETA_eta_R', 'BIC1', 'nCl', 'SssS', 'BCUTs-1h', 'BCUTdv-1l', 'AATS2d', 'TopoPSA', 'BCUTdv-1h', 'GATS3d_diff_TpiPC10', 'PEOE_VSA9', 'RotRatio', 'MATS2s', 'ATS8i', 'AATSC1v', 'TopoPSA(NO)_multiply_nG12FRing', 'ATS1i', 'Spe', 'GATS4Z_ratio_ETA_shape_y', 'NaasN', 'AATS5v', 'GATS8are', 'VR1_Dzi_ratio_nG12FARing', 'NdsCH', 'ATS7se', 'PEOE_VSA4', 'AATS4dv', 'nRot', 'GATS4i', 'ATS3are', 'piPC6', 'GGI5', 'AATS1d', 'Xp-7dv', 'SRW07', 'n9FARing', 'SaaO', 'piPC7', 'SRW04', 'AATSC5are', 'MPC10', 'MWC07', 'MWC02', 'n10FHRing', 'AATSC1p', 'VAdjMat', 'IC5', 'CIC4', 'nFAHRing', 'VE1_Dzi', 'SpDiam_A', 'SpMax_A', 'AATS0p', 'Mare', 'AATSC1i', 'n12FAHRing', 'AATS3Z', 'NddsN', 'VSA_EState4', 'SlogP_VSA1', 'VE3_D', 'GATS7c', 'AATS1Z', 'AATS0d', 'VR3_Dzv', 'AATS6m', 'ATSC6are', 'AATS6dv', 'AATS1se', 'AATS6d', 'ATS4pe', 'ATS6are', 'AATS8Z', 'AATS3v', 'VR3_Dzpe', 'ATSC8pe', 'ATS4p', 'AATS2se', 'VR2_DzZ', 'AATS2v', 'ATS7are', 'SpAbs_Dzpe', 'AATS6v', 'ATSC1are', 'GATS3m', 'GATS2v', 'ATSC0are', 'LogEE_Dzare', 'AATS1dv', 'GATS7pe', 'GATS6m', 'AATS3s', 'BCUTd-1h', 'ATS5se', 'ATS5dv', 'VR1_Dzv', 'SM1_DzZ', 'VR1_DzZ', 'BCUTc-1l', 'ATS2se', 'SpMax_Dzse', 'ATS7v', 'ATS2d', 'nC', 'VE2_A', 'LogEE_A', 'GATS3Z', 'VE1_A', 'VE3_A', 'nBridgehead', 'GATS3s', 'ATS6se', 'VR3_A', 'ATS6d', 'BCUTm-1h', 'SpDiam_Dzp', 'GATS1i', 'AXp-4dv', 'AATS8v', 'GATS4v', 'SpMAD_Dzare', 'AATS8s', 'AATS0Z', 'ATS0Z', 'GATS5are', 'ATS1pe', 'ATS2m', 'BCUTv-1l', 'GATS3se', 'nAtom', 'VE2_Dzse', 'GATS4Z', 'nF', 'LogEE_DzZ', 'nBr', 'VR2_Dzv', 'SM1_Dzse', 'SpAbs_Dzse', 'MATS1s', 'ATSC3p', 'AXp-2d', 'Xpc-4d', 'NsCl', 'Xpc-5dv', 'AATSC4se', 'NssS', 'C3SP3', 'Xp-5d', 'AATSC2se', 'AATSC1se', 'AXp-1d', 'Xc-6d', 'Radius', 'Mv', 'MATS2p', 'SsssCH', 'NdsN', 'VR3_D', 'VR2_D', 'VE2_D', 'Sv', 'LogEE_D', 'SpMAD_D', 'ETA_epsilon_1', 'MWC01', 'SpDiam_D', 'AATSC8pe', 'AATSC3m', 'AMID_C', 'SpMax_Dzse_ratio_nFRing', 'Kier2_diff_SMR_VSA1', 'EState_VSA10_multiply_Sse', 'EState_VSA10_multiply_ATS0are', 'MPC8', 'AATSC7v', 'ATSC0are_ratio_nG12FRing', 'mZagreb2', 'AATSC6pe', 'MWC03', 'ATSC1pe', 'AATSC4pe', 'n10FARing', 'nFaHRing', 'n9FaRing', 'n8FHRing', 'SRW05', 'MWC10', 'TMWC10', 'MWC04', 'SpAD_D', 'SpMax_D', 'piPC8_sum_BCUTs-1l', 'SssO', 'ETA_eta_RL', 'SpMAD_Dzi', 'SM1_Dzi', 'SaasN', 'SsF', 'C2SP2', 'SdO', 'C3SP2', 'C1SP1', 'C1SP2', 'C1SP3', 'VR3_Dzp', 'SdS', 'GATS3c', 'MATS1i', 'MATS1pe', 'MATS3m', 'MATS1m', 'VE2_Dzare', 'MATS4se', 'GATS1v', 'VR3_Dzi', 'SpMax_Dzi', 'ETA_eta_BR', 'SpAbs_D', 'NdssC', 'Si', 'MATS3are', 'Mpe', 'MATS3p', 'AXp-4d', 'NssCH2', 'AXp-5d', 'NdNH', 'MATS8pe', 'NssssC', 'NsssCH', 'VR2_Dzp', 'NtCH', 'MATS5pe', 'StN', 'MATS3pe', 'nBonds', 'ETA_alpha', 'SsBr', 'SaaS', 'VE2_Dzi', 'AETA_beta_ns', 'TopoPSA(NO)_ratio_nG12FRing', 'n8FAHRing', 'MATS8v_diff_piPC8', 'ATSC4c', 'AATS6pe', 'AATS8pe', 'ATSC0c', 'ATSC1m', 'VR3_Dzm', 'ATSC7s', 'ATSC2Z', 'ATSC6Z', 'VE2_Dzm', 'ATSC0pe_ratio_nG12FRing', 'ATSC6c', 'AATS6se', 'ATSC7c', 'ATSC8c', 'ATSC5dv', 'ATSC0d', 'GATS4d', 'VE1_Dzp', 'VE3_Dzp', 'AATSC2i', 'AMID_O', 'piPC1', 'AATS7se', 'AATS5se', 'AATSC4i', 'AATSC7s', 'BCUTi-1l', 'ATSC0pe', 'ATSC2se', 'AATSC2s', 'AATSC3d', 'AATSC4d', 'AATSC5d', 'VR3_DzZ', 'AATSC3s', 'VE2_Dzp', 'ATSC2i', 'AATS4i', 'ATSC7i', 'AATSC1c', 'AATSC2c', 'SpDiam_Dzv', 'ATSC2m', 'AATS6p', 'AATS6are', 'AATS8are', 'AATS4are', 'AATS8p', 'MPC7', 'ATSC3c', 'MDEC-33', 'n10FRing', 'SlogP_VSA10', 'MATS7dv', 'PEOE_VSA11', 'MIC0', 'SMR_VSA9', 'SlogP_VSA2', 'PEOE_VSA3', 'LabuteASA', 'ZMIC1', 'AATSC0are', 'ETA_dAlpha_B', 'fragCpx', 'VSA_EState9', 'VSA_EState2_ratio_nG12FARing', 'MATS8v_diff_piPC10', 'piPC8_sum_GATS8v', 'SM1_Dzpe_sum_MATS3p', 'AATSC0v', 'EState_VSA10_sum_AATSC4s', 'EState_VSA10_multiply_ATS7dv', 'Xp-6d_ratio_nFRing', 'ATSC0pe_ratio_nG12FARing', 'MATS8dv', 'piPC7_multiply_EState_VSA10', 'IC1', 'nAHRing', 'AATSC5p', 'EState_VSA10', 'EState_VSA8', 'EState_VSA4', 'piPC2', 'naRing', 'n5aRing', 'n6aRing', 'IC3', 'piPC3', 'SpMAD_Dzpe', 'n6AHRing', 'n9FRing', 'piPC9', 'apol', 'n5Ring', 'n7Ring', 'TIC5', 'TIC0', 'TIC1', 'TIC3', 'SIC0', 'n7AHRing', 'n5aHRing', 'AETA_eta_FL', 'MATS6pe', 'n8FRing', 'GATS6v', 'PEOE_VSA6', 'AATSC4Z', 'GhoseFilter', 'piPC5', 'ETA_eta_R', 'AATSC2pe', 'VE3_Dzi', 'AATS0are', 'ATS7pe', 'nS', 'ATS8v', 'GATS5p', 'FCSP3', 'MATS8p', 'AATSC3pe', 'SlogP_VSA3', 'GATS6dv', 'SdNH', 'TIC4', 'SpAbs_Dzv', 'GATS3d', 'MATS6Z', 'n5AHRing', 'MIC1', 'ATS0p', 'nX', 'MID', 'ATS0d', 'VR2_A', 'IC2', 'ATS3se', 'MID_N', 'SMR', 'Sp', 'SaaCH', 'MATS2i', 'Xc-3d', 'MID_C', 'NddssS', 'VE1_Dzare', 'ATS7dv', 'piPC7_sum_GATS8p', 'VR1_Dzare', 'JGI7', 'SRW02', 'nG12FARing', 'SsOH_multiply_ATS8dv', 'ATS6p', 'GATS2m', 'ATSC0Z', 'AATS4v', 'SsOH', 'ATS3Z', 'VR1_Dzp', 'NaaNH', 'SlogP_VSA7', 'GATS1m', 'MATS7p', 'EState_VSA3', 'EState_VSA6', 'MATS1v', 'GATS8p', 'ATS1se', 'NssNH', 'PEOE_VSA12', 'AXp-0dv', 'GATS8pe', 'SpMAD_Dzv', 'nBondsO', 'GGI4', 'ATSC0m', 'EState_VSA10_sum_ETA_eta_BR', 'piPC10_sum_GATS8v', 'AATS0s_multiply_ATS3pe', 'AATS7dv', 'Xp-0d', 'VR3_Dzare', 'ATS5p', 'n10FAHRing_sum_piPC8', 'ETA_dBeta', 'AATSC1s', 'AATSC3are', 'ATS8p', 'SaaNH', 'ETA_eta_R_ratio_nG12FARing', 'ATS8are', 'AATSC6are', 'AATSC4are', 'ATS5v', 'VSA_EState1', 'ATSC1pe_diff_piPC2', 'TIC2_multiply_AATS0s', 'Xp-3dv', 'nG12FAHRing', 'GATS6Z', 'ATS6dv', 'Xp-6d', 'ETA_dEpsilon_D', 'ZMIC3', 'ATS7s', 'MATS6v', 'GATS1are', 'MATS6se', 'CIC5', 'AETA_eta_B', 'SMR_VSA1', 'GATS8m', 'AATSC8c', 'VMcGowan', 'GATS6d', 'TMPC10', 'SIC3', 'ATSC6v', 'ATSC4are', 'MATS8are', 'AATSC5se', 'GATS1d', 'Xc-5d', 'GATS5d', 'AATSC5c', 'ATSC2v', 'ATSC8Z', 'ATSC1i', 'Xp-7d', 'ATS4s', 'GATS2pe', 'MID_X', 'SIC1', 'GGI5_multiply_VSA_EState3', 'GATS6s', 'ZMIC5', 'ATSC2p', 'PEOE_VSA7', 'GATS8d', 'AATS5p', 'ATSC5i', 'NdssC_ratio_Xp-6d', 'MATS6dv', 'SMR_VSA5', 'VSA_EState5', 'GATS1Z', 'ATSC5v', 'SsCH3', 'AETA_beta_s', 'BCUTpe-1l', 'GATS3i', 'AATSC2v', 'ATSC4pe', 'GATS3are', 'ATSC0i', 'BIC2', 'BCUTd-1l', 'Xp-4d_diff_MID_X', 'JGI5', 'AATS0s', 'AATSC4c', 'AATSC8v', 'GATS1dv', 'ATSC2d', 'SlogP_VSA6', 'fMF', 'MATS1se', 'AATS4se', 'Xch-7d', 'BIC4', 'GATS7se', 'MATS8s', 'MATS7v', 'GATS8i', 'NaasC', 'GATS5v', 'BCUTs-1l', 'TopoPSA(NO)_sum_ATSC4p', 'piPC8_sum_GATS7dv', 'ETA_psi_1', 'ZMIC4', 'ATSC2dv', 'ATSC6i_diff_TopoPSA', 'ATSC8v', 'AATSC2are', 'ATSC1Z', 'MATS1p', 'ATSC1v', 'Mi', 'AATSC7m', 'BalabanJ', 'JGI7_multiply_ATSC0c', 'MPC2', 'GGI10', 'EState_VSA10_sum_MATS4c', 'GATS7Z', 'GATS5Z', 'AATSC6Z', 'ATSC8dv', 'AATSC8d', 'GATS7i', 'FilterItLogS', 'AATSC3se', 'AATSC2dv', 'MATS2pe', 'AATSC6s_diff_piPC8', 'Xp-2dv', 'ATSC7d', 'LogEE_Dzse_ratio_nFRing', 'SpAD_Dzp', 'VSA_EState6', 'SpAbs_Dzpe_ratio_nFRing', 'MATS6c', 'AATSC6p', 'EState_VSA10_sum_MATS7d', 'AMID_X', 'AATSC7d', 'ATSC1se', 'GATS3dv', 'AATSC1Z', 'SsssN', 'GATS2se', 'Mp', 'GATS2dv', 'GATS5i', 'TopoPSA(NO)_sum_AATSC8m', 'GATS2s', 'SaasC', 'Xp-6dv', 'ATSC6se', 'GATS1p', 'ATSC3pe', 'AATSC0s', 'AATSC5i', 'ATSC6s', 'AETA_alpha', 'GATS7s', 'GATS5m', 'GATS4s', 'AXp-7dv', 'MIC5', 'GATS2c', 'ATSC8s', 'AATSC1dv', 'ATSC1dv', 'AXp-0d', 'ATS6Z_ratio_nG12FRing', 'GATS6c', 'random_feature', 'MATS3dv', 'ATSC3dv', 'n7HRing']DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
2022-11-15 14:03:38,994 supervised.exceptions ERROR All features are droppped! Your data looks like random data.
2022-11-15 14:03:39,121 supervised.exceptions ERROR All features are droppped! Your data looks like random data.
2022-11-15 14:03:39,208 supervised.exceptions ERROR All features are droppped! Your data looks like random data.
2022-11-15 14:03:39,307 supervised.exceptions ERROR All features are droppped! Your data looks like random data.
2022-11-15 14:03:39,395 supervised.exceptions ERROR All features are droppped! Your data looks like random data.
2022-11-15 14:03:40,163 supervised.exceptions ERROR All features are droppped! Your data looks like random data.
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
ntree_limit is deprecated, use `iteration_range` or model slicing instead.
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`
DataFrame is highly fragmented.  This is usually the result of calling `frame.insert` many times, which has poor performance.  Consider joining all columns at once using pd.concat(axis=1) instead.  To get a de-fragmented frame, use `newframe = frame.copy()`

* Step features_selection will try to check up to 6 models
There was an error during 38_RandomForest_GoldenFeatures_SelectedFeatures training.
Please check mljar_AutoML_Compete_2022_11_15_13_28_31/errors.md for details.
There was an error during 28_LightGBM_SelectedFeatures training.
Please check mljar_AutoML_Compete_2022_11_15_13_28_31/errors.md for details.
There was an error during 15_Xgboost_SelectedFeatures training.
Please check mljar_AutoML_Compete_2022_11_15_13_28_31/errors.md for details.
There was an error during 10_Default_ExtraTrees_SelectedFeatures training.
Please check mljar_AutoML_Compete_2022_11_15_13_28_31/errors.md for details.
There was an error during 29_CatBoost_SelectedFeatures training.
Please check mljar_AutoML_Compete_2022_11_15_13_28_31/errors.md for details.
There was an error during 59_NeuralNetwork_SelectedFeatures training.
Please check mljar_AutoML_Compete_2022_11_15_13_28_31/errors.md for details.
* Step hill_climbing_1 will try to check up to 29 models
65_RandomForest_GoldenFeatures rmse 17.930113 trained in 29.68 seconds
66_RandomForest_GoldenFeatures rmse 17.943753 trained in 30.62 seconds
67_RandomForest rmse 19.660678 trained in 27.75 seconds
68_RandomForest rmse 19.693258 trained in 28.49 seconds
69_RandomForest_GoldenFeatures rmse 20.030408 trained in 31.55 seconds
70_LightGBM rmse 21.397327 trained in 13.96 seconds
71_LightGBM rmse 21.22208 trained in 16.14 seconds
72_LightGBM rmse 21.966699 trained in 13.84 seconds
73_Xgboost rmse 21.997356 trained in 17.02 seconds
74_Xgboost rmse 21.674228 trained in 17.46 seconds
75_ExtraTrees rmse 21.482819 trained in 30.24 seconds
76_ExtraTrees rmse 22.038449 trained in 28.47 seconds
77_LightGBM rmse 21.737556 trained in 23.35 seconds
78_LightGBM rmse 22.433932 trained in 13.46 seconds
79_CatBoost rmse 21.912629 trained in 32.23 seconds
80_CatBoost rmse 22.536408 trained in 36.73 seconds
81_CatBoost rmse 22.241556 trained in 36.98 seconds
82_CatBoost rmse 22.156005 trained in 37.96 seconds
83_CatBoost rmse 22.355757 trained in 34.35 seconds
84_Xgboost rmse 21.891493 trained in 13.52 seconds
85_Xgboost rmse 21.891493 trained in 14.02 seconds
86_Xgboost rmse 21.882402 trained in 16.43 seconds
87_Xgboost rmse 21.884224 trained in 15.86 seconds
88_ExtraTrees rmse 22.681647 trained in 29.2 seconds
89_ExtraTrees rmse 22.351881 trained in 28.42 seconds
90_ExtraTrees rmse 22.609467 trained in 28.22 seconds
91_NeuralNetwork rmse 30.862319 trained in 27.15 seconds
92_NeuralNetwork rmse 53.140584 trained in 25.4 seconds
93_DecisionTree rmse 28.206009 trained in 11.97 seconds
* Step hill_climbing_2 will try to check up to 15 models
94_RandomForest_GoldenFeatures rmse 17.950458 trained in 31.96 seconds
95_LightGBM rmse 21.141554 trained in 17.75 seconds
96_LightGBM rmse 21.250179 trained in 18.27 seconds
97_LightGBM rmse 21.139589 trained in 17.99 seconds
98_LightGBM rmse 21.442756 trained in 15.99 seconds
99_Xgboost rmse 21.67311 trained in 23.56 seconds
100_Xgboost rmse 22.276967 trained in 16.87 seconds
101_Xgboost rmse 21.701622 trained in 26.51 seconds
102_Xgboost rmse 22.030808 trained in 32.91 seconds
103_CatBoost rmse 22.390204 trained in 35.56 seconds
104_CatBoost rmse 22.085482 trained in 38.7 seconds
105_CatBoost rmse 21.872117 trained in 31.82 seconds
106_Xgboost rmse 22.396551 trained in 19.46 seconds
107_Xgboost rmse 22.118185 trained in 16.84 seconds
108_ExtraTrees rmse 22.235697 trained in 28.28 seconds
* Step ensemble will try to check up to 1 model
Ensemble rmse 17.626355 trained in 44.76 seconds
AutoML fit time: 3301.04 seconds
AutoML best model: Ensemble
GENERATING REPORT
my_params =  {'algorithms': ['Baseline', 'Linear', 'Decision Tree', 'Random Forest', 'Extra Trees', 'LightGBM', 'Xgboost', 'CatBoost', 'Neural Network', 'Nearest Neighbors'], 'boost_on_errors': 'auto', 'eval_metric': 'auto', 'explain_level': 'auto', 'features_selection': 'auto', 'golden_features': 'auto', 'hill_climbing_steps': 'auto', 'kmeans_features': 'auto', 'max_single_prediction_time': None, 'mix_encoding': 'auto', 'ml_task': 'regression', 'mode': 'Compete', 'model_time_limit': None, 'n_jobs': -1, 'optuna_init_params': {}, 'optuna_time_budget': None, 'optuna_verbose': True, 'random_state': 763565, 'results_path': 'mljar_AutoML_Compete_2022_11_15_13_28_31', 'stack_models': 'auto', 'start_random_models': 'auto', 'top_models_to_improve': 'auto', 'total_time_limit': 72000, 'train_ensemble': True, 'validation_strategy': {'validation_type': 'custom'}, 'verbose': 1}
Best model name: Ensemble
Best model metric: =  17.62635450563578
automl.eval_metric: auto
Eval metric is  rmse

TRAINING
Metric  rmse  =  14.17855695856272
'numpy.ndarray' object has no attribute 'values'
  Metric       Score
0    MAE    9.896987
1    MSE  201.031477
2   RMSE   14.178557
3     R2    0.598382
4   MAPE    0.244458
Training score reg-R2/class-accuracy: 0.5983819028421248
K-FOLD-CV
Results files  mljar_AutoML_Compete_2022_11_15_13_28_31/Ensemble/predictions_ensemble.csv
Metric  rmse  =  17.62635450563578
x and y must be the same size
  Metric       Score
0    MAE   12.637134
1    MSE  310.688373
2   RMSE   17.626355
3     R2    0.379311
4   MAPE    0.294526
VALIDATION
Metric  rmse  =  23.614566158178118
'numpy.ndarray' object has no attribute 'values'
  Metric         Score
0    MAE  1.539717e+01
1    MSE  5.576477e+02
2   RMSE  2.361457e+01
3     R2  4.693311e-02
4   MAPE  9.301623e+15
validation score reg-R2/class-accuracy: 0.046933112125477905
Stop Tue Nov 15 02:25:55 PM CET 2022
